---
phase: 05-lambda-service-integration
type: execute
---

<objective>
Add Lambda service to the AWS comparison tool with invocation-based pricing and memory/duration configurations.

Purpose: Expand service coverage to include serverless compute, enabling users to compare Lambda costs across memory tiers and architectures (x86 vs ARM).
Output: Working Lambda comparison page with cost calculations, following established S3/Aurora service patterns.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase context
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md
@.planning/codebase/CONVENTIONS.md

# Prior summaries (for pattern reference)
@.planning/phases/01-design-foundation/01-01-SUMMARY.md
@.planning/phases/02-component-redesign/02-01-SUMMARY.md
@.planning/phases/02-component-redesign/02-02-SUMMARY.md

# Existing service implementations (pattern templates)
@src/types/s3.ts
@src/types/rds.ts
@src/utils/s3Calculator.ts
@src/utils/rdsCalculator.ts
@src/components/S3ConfigForm.tsx
@src/components/S3Comparison.tsx
@src/App.tsx

**Tech stack available:** React, TypeScript, Tailwind CSS, Framer Motion, Recharts
**Established patterns:** Generic comparison framework, calculator with adapter pattern, metadata-driven config forms, animation variants from Phase 1

**Lambda pricing model (from discovery):**
- Requests: $0.20 per 1M invocations (region-independent)
- Compute (x86): $0.0000166667 per GB-second (first 6B GB-seconds/month)
- Compute (ARM Graviton2): $0.0000133334 per GB-second (~20% cheaper)
- Memory: 128MB-10,240MB in 1MB increments
- Free tier: 1M requests + 400K GB-seconds/month
- GB-seconds = (memory in GB) × (duration in seconds)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Lambda type definitions</name>
  <files>src/types/lambda.ts</files>
  <action>
Create Lambda type definitions following S3/RDS patterns:
- LambdaArchitecture type: 'x86' | 'arm'
- LambdaConfig interface with: architecture, memoryMB (128-10240), monthlyInvocations, avgDurationMs
- LambdaCostBreakdown interface with: requestCost, computeCost, totalCost
- LAMBDA_MEMORY_TIERS constant array: Common memory values [128, 256, 512, 1024, 2048, 3008, 5120, 10240] with descriptions
- LAMBDA_ARCHITECTURE_METADATA: Record with architecture metadata (name, description, pricePerGBSecond)

Use naming conventions: PascalCase for types, UPPER_SNAKE_CASE for constants.
Follow existing type file structure (type definitions first, then metadata).
</action>
  <verify>TypeScript compilation succeeds, no errors in src/types/lambda.ts</verify>
  <done>Lambda types defined, metadata constants created, file compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Lambda cost calculator</name>
  <files>src/utils/lambdaCalculator.ts</files>
  <action>
Create Lambda calculator following s3Calculator.ts pattern:
- calculateLambdaCosts(config: LambdaConfig): LambdaCostBreakdown function
  - Request cost: (monthlyInvocations / 1_000_000) × 0.20
  - GB-seconds: (memoryMB / 1024) × (avgDurationMs / 1000) × monthlyInvocations
  - Compute cost: GB-seconds × pricePerGBSecond (from architecture metadata)
    - x86: 0.0000166667
    - arm: 0.0000133334
  - Total: requestCost + computeCost
- lambdaCostToGeneric(breakdown: LambdaCostBreakdown): GenericCostBreakdown adapter
  - Map requestCost → item "Lambda Requests"
  - Map computeCost → item "Compute Duration (GB-seconds)"
  - Return GenericCostBreakdown with items array and totalCost

Use pure functions, no hardcoded fallbacks (Lambda pricing is simpler than S3/RDS).
Import types from '../types/lambda' and '../types/comparison'.
</action>
  <verify>npm run build succeeds, calculator exports both functions, no TypeScript errors</verify>
  <done>Calculator functions implemented, adapter working, builds without errors</done>
</task>

<task type="auto">
  <name>Task 3: Create Lambda UI components</name>
  <files>src/components/LambdaConfigForm.tsx, src/components/LambdaComparison.tsx</files>
  <action>
Create Lambda UI components following S3/Aurora patterns with Phase 1-2 animation system:

**LambdaConfigForm.tsx:**
- Props: config, onChange(field, value)
- Form fields with interactiveControlVariants animations:
  1. Architecture select: x86 vs ARM with metadata descriptions
  2. Memory MB slider/input: 128-10240, suggest common tiers dropdown
  3. Monthly invocations number input with validation
  4. Average duration (ms) number input with validation
- Display calculated GB-seconds below duration: "(memory/1024) × (duration/1000) × invocations = X GB-seconds/month"
- Apply cardVariants to form container, shadow-subtle elevation
- Use errorVariants for validation errors (negative numbers, out of range)
- Follow S3ConfigForm.tsx structure and styling patterns

**LambdaComparison.tsx:**
- Use ComparisonLayout<LambdaConfig, LambdaCostBreakdown> generic component
- Pass calculateLambdaCosts, lambdaCostToGeneric, LambdaConfigForm
- Default configs: Config 1 (x86, 1024MB, 1M invocations, 200ms), Config 2 (arm, 1024MB, 1M invocations, 200ms)
- Service color: Use tertiary color (#ff9800 orange) for Lambda-specific borders/highlights (primary=S3, secondary=Aurora)
- Follow S3Comparison.tsx pattern exactly

Apply animation patterns from Phase 1: cardVariants, interactiveControlVariants, costChangeVariants.
</action>
  <verify>npm run build succeeds, components render, animations work, form validation functional</verify>
  <done>LambdaConfigForm renders with all fields and animations, LambdaComparison page displays comparison correctly</done>
</task>

<task type="auto">
  <name>Task 4: Register Lambda service in App</name>
  <files>src/App.tsx</files>
  <action>
Add Lambda to services array following existing S3/Aurora pattern:
- id: 'lambda'
- name: 'AWS Lambda'
- description: 'Serverless compute with invocation-based pricing'
- icon: Zap icon from lucide-react (serverless/lightning bolt)
- path: '/lambda'
- color: 'tertiary' (orange)
- component: LambdaComparison

Add route in Routes section: &lt;Route path="/lambda" element={&lt;LambdaComparison /&gt;} /&gt;

Import LambdaComparison and Zap icon at top of file.
Position Lambda as third service (after S3 and Aurora).
</action>
  <verify>npm run dev starts, navigate to http://localhost:5173/lambda shows Lambda comparison page, landing page shows Lambda card</verify>
  <done>Lambda registered, route working, accessible from landing page, dev server runs without errors</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors or warnings
- [ ] `npm run dev` starts successfully
- [ ] Navigate to `/lambda` displays Lambda comparison page
- [ ] Landing page shows Lambda service card with Zap icon
- [ ] Form controls are animated and responsive
- [ ] Cost calculations are accurate (verify manually with simple inputs)
- [ ] Both x86 and ARM architectures calculate correctly
- [ ] Architecture comparison shows ARM ~20% cheaper for same config
</verification>

<success_criteria>

- All 4 tasks completed
- All verification checks pass
- No TypeScript errors or build warnings
- Lambda service fully functional and matches S3/Aurora UX patterns
- Animations consistent with Phase 1-2 design system
</success_criteria>

<output>
After completion, create `.planning/phases/05-lambda-service-integration/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Lambda Core Implementation Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- Lambda type definitions with architecture and memory tier metadata
- Cost calculator with request + GB-second pricing for x86 and ARM
- Lambda config form with animated controls and validation
- Lambda comparison page using generic framework
- Service registered and accessible from landing page

## Files Created/Modified

- `src/types/lambda.ts` - Lambda types and metadata
- `src/utils/lambdaCalculator.ts` - Cost calculation logic
- `src/components/LambdaConfigForm.tsx` - Configuration form
- `src/components/LambdaComparison.tsx` - Comparison page
- `src/App.tsx` - Service registration

## Decisions Made

[Key decisions during implementation]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 5 complete. Ready for Phase 6 (ECS Service Integration).
</output>
